\documentclass{beamer}
\usepackage{amsmath}
\usepackage{listings}
\usepackage[default]{sourcecodepro}
\usepackage[default]{sourcesanspro}
\usepackage[T1]{fontenc}
\begin{document}
\title{Zero Intelligence Traders on GPUs with CUDA}
\author{David Prentiss}
\date{\today}

\lstset{
  language = C,
  basicstyle = \fontsize{7.5}{7.7}\selectfont\ttfamily,
  keywordstyle = \color{blue}
}

\frame{\titlepage}

\begin{frame}
  \frametitle{Title}
  Consider the vectors
  \begin{align*}
    \boldsymbol{a} &= \begin{bmatrix} 0 & 1 & 2 & 3 \end{bmatrix} \\
    \boldsymbol{b} &= \begin{bmatrix} 6 & 5 & 8 & 7 \end{bmatrix}
    \end{align*}
    We want to compute the dot product
  \begin{align*}
    \boldsymbol{a}\cdot\boldsymbol{b} =
    \boldsymbol{a}\boldsymbol{b}^\top & = \sum_{i=1}^n a_ib_i
    \end{align*}
\end{frame}

\begin{frame}
  \centering
  \frametitle{Title}
  \begin{array}{cccc}
    0 & 1 & 2 & 3\\
    \end{array}
    \\
  \begin{array}{|c|c|c|c|}
    \hline
    0 & 1 & 2 & 3\\
    \hline
  \end{array}
  \\
  $\times$ \\
  \begin{array}{|c|c|c|c|}
    \hline
    6 & 5 & 8 & 7\\
    \hline
  \end{array}
  \\
  $=$ \\
  \begin{array}{|c|c|c|c|}
    \hline
    0 & 5 & 16 & 21\\
    \hline
  \end{array}
  \\
  \begin{array}{|c|c|c|c|}
    \hline
    5 & 21 & 37 & 21\\
    \hline
  \end{array}
  \\
  \begin{array}{|c|c|c|c|}
    \hline
    42 & 42 & 42 & 42\\
    \hline
  \end{array}
  \\
\end{frame}

\begin{frame}
  \frametitle{Title}
  tmp
\end{frame}

\section{Comparing CUDA and pthreads}
\begin{frame}[fragile]
  \frametitle{Allocating Memory}
  pthreads
\begin{lstlisting}[frame=single]
Agent Buyers[numberOfBuyers];
Agent Sellers[numberOfSellers];
\end{lstlisting}

  CUDA
\begin{lstlisting}[frame=single]
size_t agentSize = numberOfBuyers * sizeof(Agent);
cudaMallocManaged(&Buyers, agentSize);
cudaMallocManaged(&Sellers, agentSize);
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Launching threads}
  pthreads
\begin{lstlisting}[frame=single]
int threadNumber, status;
pthread_t threads[numThreads];
int args[numThreads];

for (threadNumber = 0; threadNumber < numThreads; threadNumber++) {
    args[threadNumber] = threadNumber;
    status = pthread_create(&threads[threadNumber], NULL, DoTrades,
                            &args[threadNumber]);
}
\end{lstlisting}

  CUDA
\begin{lstlisting}[frame=single]
doTrades<<<numBlocks, numThreads>>>(Buyers, Sellers);
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Joining threads}
  pthreads
\begin{lstlisting}[frame=single]
void *threadResult[numThreads];

for (threadNumber = 0; threadNumber < numThreads; threadNumber++) {
    status = pthread_join(threads[threadNumber],
                          &threadResult[threadNumber]);
}
\end{lstlisting}

  CUDA
\begin{lstlisting}[frame=single]
cudaDeviceSynchronize();
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Threaded Function}
  pthreads
\begin{lstlisting}[frame=single]
void *DoTrades (void *threadN)
{
    int threadNum = *(int*) threadN;
    ...
    bidPrice = (rand_r(&seeds[threadNum])
        % Buyers[buyerIndex].value) + 1;
    ...
}
\end{lstlisting}

  CUDA
\begin{lstlisting}[frame=single]
__global__ void doTrades(Agent *Buyers, Agent *Sellers)
{
    curandState_t state;
    curand_init(0, 0, 0, &state);

    int threadNum = blockDim.x * blockIdx.x + threadIdx.x;
    ...
    bidPrice = (curand(&state)
        % Buyers[buyerIndex].value) + 1;
    ...
}
\end{lstlisting}
\end{frame}

\end{document}